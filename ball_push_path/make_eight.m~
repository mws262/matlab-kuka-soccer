clear all; close all;
%% Make the figure 8 spline.
% Makes a figure 8 cubic spline with periodic boundary conditions
% (continuous velocity and acceleration at the end to beginning
% transition).

% Figure 8 parameters.
time_scaling = 15; % Time to make one cycle along the 8.
lobe_length = 2; % Parameters to stretch the 8.
lobe_width = 2;
lobe_center_offset = 0.25;
height = 0; % Height of path off the ground. I see no reason to change this.

% Points which must be passed through.
knots = [0, 0, height;
    lobe_width, lobe_length/2 + lobe_center_offset, height;
    0, lobe_length, height;
    -lobe_width, lobe_length/2 + lobe_center_offset, height
    0, 0, height;
    lobe_width, -lobe_length/2 - lobe_center_offset, height;
    0, -lobe_length, height;
    -lobe_width, -lobe_length/2 - lobe_center_offset, height;
    0, 0, height]';

num_knots = size(knots,2);

% Times at each point.
breaks = linspace(0, time_scaling, num_knots);

poly_positions = csape(breaks, knots, 'periodic'); % Actually makes the spline.

poly_velocities = fnder(poly_positions,1); % Derivative to get velocity along spline.
poly_accelerations = fnder(poly_velocities,1); % Derivative to get acceleration along the spline.

% Evaluate many points along the spline for visualization.
tspan = linspace(0, breaks(end), 1000);
positions = ppval(poly_positions, tspan)';
velocities = ppval(poly_velocities, tspan)';
accelerations = ppval(poly_accelerations, tspan)';

%% Derive things about the dynamics.
syms g m I R fax fay faz fn ffx ffy rx ry vx vy ax ay wx wy wz wdx wdy wdz mu theta real;
% g - gravity
% m - ball mass
% I - ball inertia (Not using a matrix since it's a ball)
% R - ball radius
% fax - (scalar) force applied normal to the ball by the arm, xdir
% fay - (scalar) force applied normal to the ball by the arm, ydir
% faz - (scalar) force applied normal to the ball by the arm, zdir
% fn - (scalar) normal force from the ground
% ffx - (scalar) force from ground friction, x component
% ffy - (scalar) force from ground friction, y component
% vx - COM velocity in x
% vy - COM velocity in y
% ax - COM acceleration in x direction. Known from trajectory.
% ay - COM acceleration in y direction. Known from trajectory.
% wx - angular rate of ball about x axis
% wy - angular rate of ball about y axis
% wz - angular rate of ball about z axis
% wdx - angular acceleration of ball about x axis
% wdy - angular acceleration of ball about y axis
% wdz - angular acceleration of ball about z axis
% mu - ground to ball friction coefficient.
% theta - angle from horizontal along ball arc which force is applied

% X,Y,Z unit vectors
i = [1 0 0]';
j = [0 1 0]';
k = [0 0 1]';

Fn = fn*k; % Normal force is strictly vertical.
Ff = ffx*i + ffy*j; % Ground frictional forces are in the x-y plane.
Fg = -m*g*k; % Gravity is down.
Fa = fax*i + fay*j + faz*k; % Forces applied by the arm. Assumed to go directly through the COM (only forces applied in the normal direction by the arm).

Vcom = vx*i + vy*j; % Velocity of COM (known from trajectory).
Acom = ax*i + ay*j; % Acceleration of COM (known from trajectory).
w = wx*i + wy*j + wz*k; % Angular rate (world frame).
wd = wdx*i + wdy*j + wdz*k; % Angular acceleration (world frame).

rp_g = -R*k; % Ground contact point with respect to COM.

Fsum = Fn + Ff + Fg + Fa; % Sum of vector forces.
Tsum = cross(rp_g, Ff); % Sum of torques about the COM. Only ground friction does not go through the COM.

F_eqn = Fsum == m*Acom; % F = ma
T_eqn = Tsum == I*(-ay/R*i + ax/R*j); % Torque = I*alpha. I is a scalar because sphere.

% Planar forces are fully determined by trajectory. Vertical forces can be
% different.
[ffx_solve, ffy_solve, fax_solve, fay_solve] = solve(F_eqn(1:2), T_eqn(1:2), [ffx, ffy, fax, fay]) % Solve for frictional force and arm xy force components

Fnormal = solve(dot(Fsum, k), fn); % Total normal force.

% Friction cone requirement.
friction_required = sqrt(ffx_solve^2 + ffy_solve^2); 
friction_max = Fnormal*mu;

force_xy_desired = sqrt(fax_solve.^2 + fay_solve.^2); % X and Y forces needed to do this motion.

force_xyz_magnitude = force_xy_desired/cos(theta); % Results in a different force magnitude based on position along the arc of the ball. We will need bigger forces if we are pressing farther away from the equator of the ball.

force_z_applied = -sin(theta) * force_xyz_magnitude; % And the total "downforce" depending on the position along the arc of the ball.

friction_actual_max = subs(friction_max, faz, force_z_applied);

% No slip at arm contact point gives actuator motion requirements.
no_slip_ground_eqn = cross(w,-rp_g) == Vcom;
[wx, wy, wz] = solve(no_slip_ground_eqn, w); % Find angular rate based on COM velocity. Note that wz stays zero under assumptions.

arm_contact_pt_equator = -R*Acom/norm(Acom); % Arm must push somewhere on the arc going from this point on the ball to the top and from this point to the bottom in world coordinates.
full_contact_arc = arm_contact_pt_equator*cos(theta) + R*sin(theta)*k; % Contact point can be on this arc for theta (-pi/2, pi/2) in world coordinates.
full_contact_arc_shifted = full_contact_arc + R*k + rx*i + ry*j; % Shift to position and height of ball.

% Analytic pose integration?
% syms qw qx qy qz real;
% wq = [0, wx, wy, wz];
% q = [qw, qx, qy, qz];

% quatprod(wq, q)

%% Make functions for various symbolic equations (to avoid eval() confusion).
friction_required_fcn = matlabFunction(friction_required);
x_force_required_fcn = matlabFunction(fax_solve); % Required x component of force applied by arm.
y_force_required_fcn = matlabFunction(fay_solve);
angular_rate_wx_fcn = matlabFunction(wx);
angular_rate_wy_fcn = matlabFunction(wy);
contact_arc_fcn = matlabFunction(full_contact_arc_shifted');
contact_arc_centered_fcn = matlabFunction(full_contact_arc');

%% Visualization.
% Lazy evaluation of symbolic stuff -- plug in values.
I_num = 1;
m_num = 1;
R_num = 0.1;

scene_fig = figure;
hold on;

% Plot positions along spline.
plot(positions(:,1), positions(:,2)); 

% Evaluate and plot forces along the spline.
f_vec_spacing = 6;
f_vec_scaling = 3;
applied_fx_eval = x_force_required_fcn(I_num, R_num, accelerations(:,1), m_num);
applied_fy_eval = y_force_required_fcn(I_num, R_num, accelerations(:,2), m_num);
quiver(positions(1:f_vec_spacing:end,1), positions(1:f_vec_spacing:end,2), f_vec_scaling*applied_fx_eval(1:f_vec_spacing:end), f_vec_scaling*applied_fy_eval(1:f_vec_spacing:end));

% Make the ball as a patch object.
[sphere_x,sphere_y,sphere_z] = sphere(30);
ball_patch = patch(surf2patch(R_num * sphere_x, R_num * sphere_y, R_num * sphere_z, R_num * sphere_z)); 
ball_verts_untransformed = ball_patch.Vertices;
ball_patch.Vertices = ball_verts_untransformed + repmat(positions(1,:)  + [0, 0, R_num], [size(ball_verts_untransformed,1),1]);
ball_patch.FaceColor = [0.8,0.5,0.5];
ball_patch.EdgeAlpha = 0.5;
ball_patch.FaceAlpha = 0.8;

% Arc on the ball representing possible places the arm could push.
push_arc_plot = plot(0,0,'g','LineWidth',5);

% Plane representing an object pushing the ball.
[plane_x, plane_y] = meshgrid(-3:0.2:3); % Generate x and y data
[plane_z] = zeros(size(plane_x, 1)); % Generate z data
plane_patch = patch(surf2patch(plane_x, plane_y, plane_z)); % Makes the plane, but the normal vector is in the z-direction.
plane_patch.FaceColor = [0.5,0.8,0.5];
plane_patch.EdgeAlpha = 0.5;
plane_patch.FaceAlpha = 0.3;
plane_patch_verts = ([1, 0, 0; 0, 0, -1; 0 1 0]*plane_patch.Vertices')'; % Rotate the plane to align with the x axis (i.e. normal in y-direction).
plane_patch.Vertices = plane_patch_verts;

plane_x_offset = 0; % Shifting the visible part of the plane along the mathematical plane it represents.
plane_y_offset = 0;

% Floor plane representing surface that the ball is rolling on.
[floor_x, floor_y] = meshgrid(-3:0.5:3); % Generate x and y data
[floor_z] = zeros(size(floor_x, 1)); % Generate z data
floor_patch = patch(surf2patch(floor_x, floor_y, floor_z));
floor_patch.FaceColor = [0.8,0.8,0.6];
floor_patch.EdgeAlpha = 0.3;
floor_patch.FaceAlpha = 1;
%shading faceted; 

% Whole scene settings.
axis([-3, 3, -3, 3]);
daspect([1,1,1]);
scene_fig.Children.Visible = 'off';
scene_fig.Position = [200, 200, 2000, 2000];

zero_vec_pts = zeros(size(positions,1),1);

rotationQ = [1 0 0 0]; % Quaternion representing ball rotation.
w_num = [angular_rate_wx_fcn(R_num, velocities(:,2)), angular_rate_wy_fcn(R_num, velocities(:,1)), zero_vec_pts]; % World frame angular rate.
w_numQ = [zero_vec_pts, w_num]; % Angular rate with 0 in front for quaternion rotation.
arc_range = transpose(-pi/2:0.05:pi/2); % Range along the ball that the potential contact arc will be plotted.

%% Animation loop.
animation_speed_factor = 0.5;
tic;
prev_time = 0;
curr_time= 0;
while (curr_time < tspan(end))
    h = curr_time - prev_time; % Time interval of this loop.
    
    % Interpolate data for the current plotting time.
    wInterp = interp1(tspan, w_num, curr_time); % Angular rate.
    wQInterp = interp1(tspan, w_numQ, curr_time);
    
    positionsInterp = interp1(tspan, positions, curr_time);
    velsInterp = interp1(tspan, velocities, curr_time);
    accelsInterp = interp1(tspan, accelerations, curr_time);
    
    % Integrate angular rate to get ball orientations. TODO: either
    % precalculate or at least improve integration
    rotationQ = 0.5 * quatprod(wQInterp, rotationQ) * h + rotationQ;
    rotationQ = rotationQ/norm(rotationQ);
    reverseQ = rotationQ .* [-1 1 1 1]; % MATLAB's reverse right-hand-rule for quaternions. Wow!
    ball_patch.Vertices = quatrotate(reverseQ, ball_verts_untransformed) + repmat(positionsInterp  + [0, 0, R_num], [size(ball_verts_untransformed,1),1]);
    
 
    % Make the arc along the ball on which we could apply the appropriate
    % force.
    R_norm_accel = -R_num*accelsInterp/norm(accelsInterp);
    
    world_push_arc = contact_arc_fcn(R_num, accelsInterp(1), accelsInterp(2), positionsInterp(1), positionsInterp(2), arc_range); % Offset by ball height and position.
    world_push_arc_center = contact_arc_centered_fcn(R_num, accelsInterp(1), accelsInterp(2), 0); % NOT offset.
    push_arc_plot.XData = world_push_arc(:,1);
    push_arc_plot.YData = world_push_arc(:,2);
    push_arc_plot.ZData = world_push_arc(:,3);
    
    % Tangent plane.
    center_ang_cos = dot(-R_norm_accel/R_num, [0; 1; 0]);
    center_ang_sin = dot(cross([0;1;0],-R_norm_accel/R_num),[0;0;1]);
    plane_rotation = [center_ang_cos, -center_ang_sin, 0; center_ang_sin, center_ang_cos, 0; 0 0 1];
    
    plane_surf_vel = cross(wInterp, world_push_arc_center) + velsInterp; 
    plane_x_offset = plane_x_offset + plane_surf_vel(1) * h; % Integrate tangent surface velocity.
    plane_y_offset = plane_y_offset + plane_surf_vel(2) * h;
   
    plane_patch.Vertices = (plane_rotation*(plane_patch_verts + repmat([plane_x_offset, 0, plane_y_offset], [size(plane_patch_verts,1),1]))')' + world_push_arc_center + positionsInterp;

    drawnow;
    prev_time = curr_time;
    curr_time = toc*animation_speed_factor;
end

% % Evaluating friction along the arc of the ball.
% fig2 = figure;
% hold on;
% daspect([1,1,1])
% ballX = linspace(0, R, 100);
% ballY = sqrt(R^2 - ballX.^2);
% plot(ballX, ballY, ballX, -ballY);
% 
% theta = linspace(-pi/2 + 0.15, pi/2 - 0.15, 100);
% mu = 1;
% g = 10;
% 
% 
% applied_force_eval = eval(force_xyz_magnitude);
% friction_cone_max = eval(friction_actual_max);
% 
% idx_along_path = 2;
% enough_fric_idx = (friction_cone_max(idx_along_path,:) - friction_req_eval(idx_along_path)) > 0;
% first_ok_idx = find(enough_fric_idx, 1, 'first');
% quiver(cos(theta), sin(theta), -cos(theta).*applied_force_eval(idx_along_path,:), -sin(theta).*applied_force_eval(idx_along_path,:))
% quiver(cos(theta(enough_fric_idx)), sin(theta(enough_fric_idx)), zeros(1,sum(enough_fric_idx)), (friction_cone_max(idx_along_path,enough_fric_idx) - friction_req_eval(idx_along_path)))
% plot([0,cos(theta(first_ok_idx))], [0,sin(theta(first_ok_idx))],'g',[0,0],[0,R],'g', 'LineWidth', 5);
% 
% fig2.Position = [100,100, 1000,1000];
% fig2.Children.Visible = 'off'
% legend('ball profile','ball profile', 'Arm force required', 'Friction cone "to spare"', 'ok region to push');
% 
% first_ok_angle = zeros(size(positions,1),1);
% for i = 1:size(positions,1)
%     first_ok_angle(i) = theta(find((friction_cone_max(i,:) - friction_req_eval(i)) > 0, 1, 'first'));
% end
% 
% 
% normal_to_curve = cross(velocities,repmat([0,0,1],size(velocities,1),1));
% unit_normal_to_curve = -(normal_to_curve./hypot(normal_to_curve(:,1), normal_to_curve(:,2)));
% ok_pt = (unit_normal_to_curve.*cos(first_ok_angle) + repmat([0,0,1],size(velocities,1),1).*sin(first_ok_angle))*0.2 + positions;

% figure;
% plot(first_ok_angle)
% fig3 = figure;
% hold on;
% daspect([1,1,1])
% plot(positions(:,1), positions(:,2));
% plot3([positions(:,1), ok_pt(:,1)]', [positions(:,2), ok_pt(:,2)]', [positions(:,3), ok_pt(:,3)]')
% %plot3(positions(:,1), positions(:,2), positions(:,3) + 0.02, '.', 'MarkerSize', 5)
% quiver(positions(:,1), positions(:,2), fx_applied, fy_applied);
% %quiver(positions(:,1), positions(:,2), friction_req_eval, zeros(size(friction_req_eval)));
% fig3.Children.Visible = 'off'








